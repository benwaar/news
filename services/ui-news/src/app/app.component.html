<h1>News UI (Angular)</h1>
<!-- Env indicator and subtle dev background overlay -->
<div class="env-indicator" [class.dev]="isDev" [class.prod]="!isDev">{{ envLabel }}</div>
<div class="api-indicator">{{ apiLabel }}</div>
<div class="dev-cascade" *ngIf="isDev"></div>
<div class="spaced">
  <label for="authMode">Auth Mode:&nbsp;</label>
  <select id="authMode" (change)="onModeChange($event)">
    <option *ngFor="let m of authModes" [selected]="m===authMode" [value]="m">{{ m }}</option>
  </select>
  <span *ngIf="authMode!=='plain'" style="margin-left:8px">(scaffolded; plain mode active)</span>
  <span *ngIf="authMode==='plain'" style="margin-left:8px">(plain manual PKCE)</span>
  </div>
<div class="badge">Realm: <strong>news</strong>
  <button (click)="login()" *ngIf="!loggedIn" [disabled]="authMode!=='plain'">Login</button>
  <button (click)="logout()" *ngIf="loggedIn" [disabled]="authMode!=='plain'">Logout</button>
</div>

<!-- Main tabs: Basics / JWT Lab -->
<div class="tabs">
  <div class="tab-list">
    <button *ngFor="let t of mainTabs"
            class="tab"
            [class.active]="selectedMainTab===t.id"
            (click)="selectMainTab(t.id)">{{ t.label }}</button>
  </div>

  <!-- Basics tab content (existing functionality) -->
  <div class="tab-content" *ngIf="selectedMainTab==='basics'">
    <h2>Basics</h2>
    <p>API health via UI proxy:</p>
    <pre>{{ health | json }}</pre>
    <div *ngIf="loggedIn">
      <p class="spaced">
        <a [href]="accountUrl" target="_blank" rel="noopener noreferrer">Open Account Console</a>
      </p>
      <p>
        <button (click)="validateToken()" [disabled]="!accessToken || authMode!=='plain'">Validate Token</button>
        <button (click)="fetchRss()" [disabled]="!accessToken || authMode!=='plain'">Fetch RSS</button>
        <button (click)="toggleToken()" [disabled]="!accessToken">{{ showToken ? 'Hide' : 'Show' }} Token</button>
        <button (click)="copyToken()" [disabled]="!accessToken || authMode!=='plain'">Copy Token</button>
        <button (click)="adminPing()" [disabled]="!accessToken || authMode!=='plain'">Admin Ping</button>
      </p>
      <p *ngIf="accessTokenExp">
        Token expires at: {{ accessTokenExp * 1000 | date:'medium' }}
        <br />
        Expires in: {{ accessTokenExpiresIn }}s
      </p>
      <div *ngIf="showToken && accessToken">
        <h3>Access Token (debug)</h3>
        <textarea rows="6" readonly>{{ accessToken }}</textarea>
        <h4>Decoded Claims</h4>
        <pre>{{ tokenPayload | json }}</pre>
        <div class="spaced">
          <h4>Claims Checklist (dev)</h4>
          <ul>
            <li>Header alg (Algorithm): <strong>{{ basicsClaims.alg || 'n/a' }}</strong></li>
            <li>[iss] Issuer present: <strong [style.color]="basicsClaims.issOk ? 'green' : 'crimson'">{{ basicsClaims.issOk ? 'yes' : 'no' }}</strong></li>
            <li>[aud] Audience: <strong>{{ basicsClaims.aud ? basicsClaims.aud.join(', ') : 'n/a' }}</strong></li>
            <li>[sub] Subject present: <strong [style.color]="basicsClaims.subOk ? 'green' : 'crimson'">{{ basicsClaims.subOk ? 'yes' : 'no' }}</strong></li>
            <li>[exp] Expires valid (not expired): <strong [style.color]="basicsClaims.expOk ? 'green' : 'crimson'">{{ basicsClaims.expOk ? 'yes' : 'no' }}</strong></li>
          <div class="info-panel">
            <p>
              Interceptor attached Authorization? <strong>{{ intAttached ? 'Yes' : 'No' }}</strong>
              <span *ngIf="intLastUrl">(last URL: <code>{{ intLastUrl }}</code>)</span>
            </p>
            <p *ngIf="intLastToken">
              <button (click)="intShowAttachedToken = !intShowAttachedToken">
                {{ intShowAttachedToken ? 'Hide' : 'Show' }} attached token
              </button>
            </p>
            <div *ngIf="intShowAttachedToken && intLastToken">
              <h4>Attached Token</h4>
              <pre>{{ intLastToken }}</pre>
            </div>
            <div *ngIf="intLastHeader">
              <h4>Authorization Header</h4>
              <pre>{{ intLastHeader }}</pre>
            </div>
          </div>
            <li>Roles/Groups: <strong>{{ basicsClaims.roles ? basicsClaims.roles.join(', ') : 'n/a' }}</strong></li>
          </ul>
        </div>
      </div>
      <div *ngIf="tokenValidation">
        <h3>Token Validation</h3>
        <pre>{{ tokenValidation | json }}</pre>
      </div>
      <div *ngIf="rss">
        <h3>RSS (via API)</h3>
        <pre>{{ rss | json }}</pre>
      </div>
      <div *ngIf="adminPingStatus !== null">
        <h3>Admin Ping</h3>
        <p>Status: {{ adminPingStatus }}</p>
        <pre>{{ adminPingResponse | json }}</pre>
      </div>
    </div>
    <div *ngIf="error" class="error">{{ error }}</div>
  </div>

<hr />
  <!-- JWT Lab tabs grouped under main tab -->
  <div class="tab-content" *ngIf="selectedMainTab==='jwt-lab'">
    <h2>JWT Lab</h2>

<div class="tabs">
  <div class="tab-list">
    <button *ngFor="let t of labTabs"
            class="tab"
            [class.active]="selectedLabTab===t.id"
            (click)="selectLabTab(t.id)">
      {{ t.label }}
      <span *ngIf="!t.ready" title="Coming soon">(soon)</span>
    </button>
  </div>

  <!-- HS256 (basic) tab -->
  <div class="tab-content" *ngIf="selectedLabTab==='hs256-basic'">
    <h3>HS256 (Basic)</h3>
    <div class="warning">
      Educational only: HS256 in-browser puts the signing secret in JS.
      Real IdPs (e.g., Keycloak) sign tokens server-side (RS256). We use HS256 here
      to make JWT structure and signing tangible in one page.
    </div>
    <div class="info-panel">
      <h4>Glossary</h4>
      <ul>
        <li><strong>JWT</strong>: header + payload + signature (base64url segments).</li>
        <li><strong>HS256</strong>: HMAC-SHA256 over <em>header.payload</em> using a shared secret.</li>
        <li><strong>base64url</strong>: URL-safe base64 without padding.</li>
        <li><strong>exp</strong>: Expiration (Unix seconds). Token invalid after this time.</li>
        <li><strong>iat</strong>: Issued-at (Unix seconds).</li>
        <li><strong>sub</strong>: Subject (stable user identifier).</li>
      </ul>
    </div>
    <div class="info-panel">
      <p>
        This tab demonstrates the anatomy of a JWT and what the signature actually protects. You build
        base64url(header).base64url(payload) and sign that exact string, so changing either part breaks the signature.
        We also surface common claims like <code>sub</code>, <code>exp</code>, and <code>iat</code> so you can see how
        they affect token validity (e.g., an <code>exp</code> countdown). Because HS256 uses a shared secret, putting the
        signer in the browser is only for learning — real systems keep secrets server-side and avoid exposing them to JS.
      </p>
    </div>
    <div>
      <label>Secret:&nbsp;</label>
      <input type="text" [(ngModel)]="labSecret" placeholder="secret" style="width: 240px;" />
    </div>
    <div class="spaced">
      <label>TTL (seconds):&nbsp;</label>
      <input type="number" [(ngModel)]="labTtl" min="0" style="width: 120px;" />
    </div>
    <div>
      <label>Payload (JSON):</label>
      <textarea rows="6" [(ngModel)]="labPayloadText" placeholder='{"sub":"123","name":"Alice"}'></textarea>
    </div>
    <p>
      <button (click)="labGenerate()">Generate JWT (HS256)</button>
    </p>
    <div>
      <label>Token:</label>
      <textarea rows="4" [(ngModel)]="labInput" placeholder="<header>.<payload>.<signature>"></textarea>
    </div>
    <p>
      <button (click)="labDecode()">Decode</button>
      <button (click)="labVerifyNow()">Verify (HS256)</button>
      <span *ngIf="labVerify !== null" [style.color]="labVerify ? 'green' : 'crimson'">{{ labVerify ? 'signature valid' : 'invalid signature' }}</span>
      <span *ngIf="labError" class="error" style="margin-left: 12px;">{{ labError }}</span>
    </p>
    <p class="spaced">
      <a href="https://www.jwt.io/" target="_blank" rel="noopener noreferrer">Open jwt.io (decode/inspect)</a>
    </p>
    <div class="grid">
      <div>
        <h4>Decoded Header</h4>
        <pre>{{ labDecodedHeader | json }}</pre>
      </div>
      <div>
        <h4>Decoded Payload</h4>
        <pre>{{ labDecodedPayload | json }}</pre>
        <p *ngIf="labExpiresIn !== null">Expires in: {{ labExpiresIn }}s</p>
        <div class="spaced">
          <h4>Claims Checklist (dev)</h4>
          <ul>
            <li>Header alg (Algorithm): <strong>{{ labDecodedHeader?.alg || 'n/a' }}</strong></li>
            <li>[sub] Subject present: <strong [style.color]="labDecodedPayload?.sub ? 'green' : 'crimson'">{{ labDecodedPayload?.sub ? 'yes' : 'no' }}</strong></li>
            <li>[exp] Expires present: <strong [style.color]="(labDecodedPayload?.exp !== undefined) ? 'green' : 'crimson'">{{ (labDecodedPayload?.exp !== undefined) ? 'yes' : 'no' }}</strong></li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- RS256 + JWKS placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='rs256-jwks'">
    <h3>RS256 + JWKS</h3>
    <div class="warning">Dev-only: Verify RS256 signatures in the browser with JWKS. Real verification should happen in your API.</div>
    <div class="info-panel">
      <h4>Glossary</h4>
      <ul>
        <li><strong>RS256</strong>: RSA with SHA-256; asymmetric signing (private key) and verification (public key).</li>
        <li><strong>kid</strong>: Key ID in the JWT header to select the correct public key.</li>
        <li><strong>JWKS</strong>: JSON Web Key Set published by the issuer; contains public keys.</li>
        <li><strong>iss</strong>: Issuer URL; should match your realm.</li>
        <li><strong>aud</strong>: Audience; should include your API/client as intended recipient.</li>
      </ul>
    </div>
    <div class="info-panel">
      <p>
        RS256 uses asymmetric keys: Keycloak signs with a private key and publishes matching public keys via JWKS.
        The token header contains a <code>kid</code> to select the right key. Your API normally fetches JWKS and verifies
        the signature server-side, then checks claims like <code>iss</code>, <code>aud</code>, and <code>exp</code>.
        Here we replicate that flow only for study: decode to get <code>kid</code>, fetch the realm JWKS, and verify the
        signature against the selected public key.
      </p>
    </div>
    <div>
      <label>Token:</label>
      <textarea rows="4" [(ngModel)]="rsTokenInput" placeholder="paste a Keycloak access token"></textarea>
    </div>
    <p>
      <button (click)="rsDecodeToken()">Decode + Extract kid</button>
      <span *ngIf="rsKid">kid: <strong>{{ rsKid }}</strong></span>
    </p>
    <p>
      <button (click)="rsFetchJwks()">Fetch JWKS (realm)</button>
      <button (click)="rsVerifyWithJwks()" [disabled]="!rsKid || rsJwks.length===0">Verify (RS256 + JWKS)</button>
      <span *ngIf="rsVerify !== null" [style.color]="rsVerify ? 'green' : 'crimson'">{{ rsVerify ? 'signature valid' : 'invalid signature' }}</span>
      <span *ngIf="rsError" class="error" style="margin-left: 12px;">{{ rsError }}</span>
    </p>
    <div class="grid">
      <div>
        <h4>Decoded Header</h4>
        <pre>{{ rsDecodedHeader | json }}</pre>
      </div>
      <div>
        <h4>Decoded Payload</h4>
        <pre>{{ rsDecodedPayload | json }}</pre>
      </div>
    </div>
  </div>

  <!-- OIDC Code+PKCE placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='oidc-pkce'">
    <h3>OIDC Code + PKCE</h3>
    <div class="warning">Dev-only introspection of the Code+PKCE flow. Real apps should not expose these values in production.</div>
    <div class="info-panel">
      <h4>What you'll see</h4>
      <ul>
        <li><strong>code_verifier</strong>: generated in the browser and stored in sessionStorage.</li>
        <li><strong>code_challenge (S256)</strong>: derived from the verifier; sent to the auth endpoint.</li>
        <li><strong>Auth URL</strong>: the computed authorization request (includes challenge).</li>
        <li><strong>Token request</strong>: POST params to the token endpoint including verifier.</li>
        <li><strong>Token response</strong>: JSON returned (e.g., <em>access_token</em>, <em>id_token</em> if present).</li>
      </ul>
      <p>
        This tab exposes the <em>normally invisible</em> parts of the browser OIDC flow so you can build intuition:
        how the client creates a <strong>code_verifier</strong>, commits to it via a <strong>code_challenge</strong>,
        and later proves possession of the verifier to the token endpoint. Seeing the exact auth URL and token request
        helps debug misconfigurations (redirect URIs, scopes, client IDs) and verify that PKCE is truly in effect.
      </p>
      <h4>What is PKCE?</h4>
      <p>
        <strong>Proof Key for Code Exchange (PKCE)</strong> binds the authorization code to your browser session.
        The SPA generates a random <em>code_verifier</em> and sends a derived <em>code_challenge</em> (S256) with the
        initial auth request. Later, the token endpoint requires the original verifier to exchange the code. If an
        attacker intercepts the authorization code, they still can’t redeem it without your verifier.
        PKCE is required for public clients (SPAs) and removes the need for a client secret in the browser.
      </p>
      <h4>Why we do it</h4>
      <ul>
        <li><strong>Verify PKCE binding</strong>: confirm the server requires the same <em>code_verifier</em> that produced the challenge (prevents intercepted authorization code replay).</li>
        <li><strong>Debug the flow</strong>: quickly spot wrong realm/client IDs, missing scopes, or redirect URI mismatches.</li>
        <li><strong>Understand token types</strong>: differentiate <em>access_token</em> (for APIs) from <em>id_token</em> (for client UI).</li>
        <li><strong>Observe timings</strong>: relate login redirects, token issuance, and token expiration to real UX.</li>
        <li><strong>Production hygiene</strong>: learn what to <em>never</em> log or expose in prod (verifiers, full tokens).</li>
      </ul>
      <h4>Where it fits in the browser flow</h4>
      <ol>
        <li><strong>SPA starts</strong>: generate a <em>code_verifier</em>; derive <em>code_challenge</em> (S256).</li>
        <li><strong>Auth request</strong>: redirect to the realm’s auth endpoint with client ID, redirect URI, scopes, and the challenge.</li>
        <li><strong>Login at IdP</strong>: user authenticates (and consents if required).</li>
        <li><strong>Redirect back</strong>: IdP returns an <em>authorization code</em> to the SPA’s redirect URI.</li>
        <li><strong>Token exchange</strong>: SPA POSTs the code and <em>code_verifier</em> to the token endpoint; server verifies it matches the earlier challenge.</li>
        <li><strong>Tokens issued</strong>: receive <em>access_token</em> (and possibly <em>id_token</em>); store access token per your strategy (here: sessionStorage).</li>
        <li><strong>API calls</strong>: attach <code>Authorization: Bearer &lt;access_token&gt;</code> to calls (through the UI gateway proxy to <em>news-api</em>).</li>
        <li><strong>Expiration/Logout</strong>: when the token expires, prompt re-login (or refresh if implemented); logout clears local state and calls the realm logout endpoint.</li>
      </ol>
    </div>
    <p>
      <button (click)="loadPkceDebug()">Refresh PKCE Details</button>
      <button (click)="login()" [disabled]="authMode!=='plain'">Start Login (Code+PKCE)</button>
    </p>
    <div class="grid">
      <div>
        <h4>PKCE Inputs</h4>
        <ul>
          <li>code_verifier: <strong>{{ pkceDebug?.verifier || 'n/a' }}</strong></li>
          <li>code_challenge: <strong>{{ pkceDebug?.challenge || 'n/a' }}</strong></li>
          <li>method: <strong>{{ pkceDebug?.challenge_method || 'n/a' }}</strong></li>
        </ul>
        <h4>Auth Request</h4>
        <pre>{{ pkceDebug?.auth_url || 'n/a' }}</pre>
      </div>
      <div>
        <h4>Token Request (POST)</h4>
        <pre>{{ pkceDebug?.token_request | json }}</pre>
        <h4>Token Response</h4>
        <pre>{{ pkceDebug?.token_response | json }}</pre>
      </div>
    </div>
  </div>

  <!-- Interceptor: Attach placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='interceptor'">
    <h3>HTTP Interceptor: Attach</h3>
    <div class="info-panel">
      <p>
        This demo uses an Angular <strong>HttpInterceptor</strong> to automatically attach
        <code>Authorization: Bearer &lt;access_token&gt;</code> to allowlisted API calls (e.g. <code>/api/*</code>).
        The token is read from sessionStorage where the plain PKCE login stored it.
      </p>
      <ul>
        <li><strong>Allowlist</strong>: only relative <code>/api/...</code> or absolute <code>https://localhost/api/...</code>.</li>
        <li><strong>Source</strong>: token from <em>sessionStorage</em> key <code>token:news:news-web</code>.</li>
        <li><strong>Scope</strong>: Interceptor affects Angular <em>HttpClient</em> calls only (not <em>fetch()</em>).</li>
      </ul>
      <div class="warning">Interceptor applies <strong>only</strong> to Angular <em>HttpClient</em>.
        Calls made with <em>fetch()</em> do <strong>not</strong> use the interceptor and will not have the header automatically attached.
        Use the buttons below (HttpClient) to see the attached <code>Authorization</code> header.
      </div>
    </div>
    <p>
      <button (click)="intHealthzHttp()">Healthz via HttpClient</button>
      <br>
      <button (click)="intValidateToken()" [disabled]="!loggedIn">Validate via HttpClient</button>
      <button (click)="intFetchRss()" [disabled]="!loggedIn">Fetch RSS via HttpClient</button>
    </p>
    <div class="info-panel">
      <p>
        Interceptor attached Authorization? <strong>{{ intAttached ? 'Yes' : 'No' }}</strong>
        <span *ngIf="intLastUrl">(last URL: <code>{{ intLastUrl }}</code>)</span>
      </p>
      <p *ngIf="intLastToken">
        <!-- Attached token toggle removed (redundant with header display) -->
      </p>
      <div *ngIf="intLastHeader">
        <h4>Authorization Header</h4>
        <pre>{{ intLastHeader }}</pre>
      </div>
    </div>
    <div *ngIf="intValidation">
      <h4>Validation (interceptor)</h4>
      <pre>{{ intValidation | json }}</pre>
    </div>
    <div *ngIf="intRss">
      <h4>RSS (interceptor)</h4>
      <pre>{{ intRss | json }}</pre>
    </div>
    <div *ngIf="intAdminStatus !== null">
      <h4>Admin Ping (interceptor)</h4>
      <p>Status: {{ intAdminStatus }}</p>
      <pre>{{ intAdminBody | json }}</pre>
    </div>
    <div *ngIf="intHealthz">
      <h4>Healthz (interceptor)</h4>
      <pre>{{ intHealthz | json }}</pre>
    </div>
  </div>

  <!-- Refresh flow placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='refresh'">
    <h3>401 → Refresh → Retry</h3>
    <div class="info-panel">
      <p>
        When a protected HTTP call returns <strong>401 Unauthorized</strong>, the interceptor will attempt a
        <strong>refresh_token</strong> exchange. On success, it retries the original request with the new
        <code>Authorization</code> header. A single refresh is kept <em>in-flight</em> to prevent storms,
        and concurrent requests wait for the outcome.
      </p>
      <ul>
        <li><strong>Demo</strong>: simulate an <em>expired/invalid</em> access token, then call a protected endpoint via HttpClient.</li>
        <li><strong>Note</strong>: fetch() bypasses interceptors — use the buttons below.</li>
      </ul>
      <div class="warning">
        Refresh helps when the <em>access token</em> is expired/invalid but a valid <em>refresh token</em> is still present.
        It will <strong>not</strong> fix:<br>
        — Missing bearer (no Authorization header attached)<br>
        — Wrong issuer/audience claims<br>
        — Malformed/unsigned tokens that your IdP rejects on refresh as well<br>
        — Authorization failures like 403 (e.g., missing required realm roles)
      </div>
      <p>
        The <strong>refresh token</strong> is used by the client (browser) to call the IdP’s token endpoint, not the API.
        After a <em>401 Unauthorized</em> due to an expired access token, the client can refresh, get a new access token, and retry.
      </p>
      <p>
        <strong>Why you rarely see it:</strong> Good UX proactively refreshes slightly before expiry (or uses silent re-auth),
        so requests don’t collide with expiry.
      </p>
    </div>
    <p>
      <button (click)="forceExpireToken()">Simulate expired access token</button>
      <button (click)="intFetchRssRefreshDemo()" [disabled]="!loggedIn">Fetch RSS via HttpClient (refresh demo)</button>
      <button (click)="rotateRefreshTokenNow()" [disabled]="!loggedIn">Rotate tokens now (refresh grant)</button>
    </p>
    <div class="grid">
      <div>
        <h4>Access Token (current)</h4>
        <pre>{{ refreshAccessToken || 'n/a' }}</pre>
      </div>
      <div>
        <h4>Refresh Token (current)</h4>
        <pre>{{ refreshRefreshToken || 'n/a' }}</pre>
      </div>
    </div>
    <div *ngIf="intRss">
      <h4>RSS (after refresh)</h4>
      <pre>{{ intRss | json }}</pre>
    </div>
  </div>

  <!-- Storage options placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='storage'">
    <h3>Storage Options</h3>
    <div class="info-panel">
      <h4>Overview</h4>
      <ul>
        <li><strong>Memory</strong>: token lives only in this Angular runtime; disappears on reload.</li>
        <li><strong>sessionStorage</strong>: per-tab storage; cleared when the tab closes; not shared across tabs.</li>
        <li><strong>localStorage</strong>: persists across tabs and browser restarts on the same origin.</li>
        <li><strong>HttpOnly Cookie (BFF)</strong>: cookie is not readable by JS; server (BFF) uses it to call APIs. <em>Out of scope in this project.</em></li>
      </ul>
      <h4>Security</h4>
      <ol>
        <li><strong>HttpOnly Cookie (BFF)</strong> — most secure: tokens never exposed to JavaScript; requires CSRF protections and cookie hardening.</li>
        <li><strong>Memory</strong> — safer for SPAs: no persistence; vulnerable only while page is loaded (still exposed to XSS).</li>
        <li><strong>sessionStorage</strong> — moderate: per-tab and cleared on close, but readable by JavaScript and survives reload in that tab.</li>
        <li><strong>localStorage</strong> — least secure: persistent and shared across tabs; fully readable by JavaScript (highest XSS persistence risk).</li>
      </ol>
      <h5>How to view in DevTools</h5>
      <ul>
        <li><strong>localStorage</strong>: Open DevTools → Application → Local Storage → your origin; look for key <code>token:news:news-web</code>. Or run <code>localStorage.getItem('token:news:news-web')</code> in the Console.</li>
        <li><strong>Memory</strong>: Not stored in Web Storage. After clicking <em>Save current access token to selected</em> with <em>Memory</em> chosen, see the “Memory” box below. You can also make a protected call and inspect the <code>Authorization</code> header in the Network tab, or check the Basics → Interceptor panel.</li>
      </ul>
      <h5>Attacker POV (runtime JS)</h5>
      <ul>
        <li>If a malicious script runs in-page (XSS/extension), it can capture in‑memory tokens by <em>hooking request headers</em> set by Angular HttpClient (XHR) or by reading the Network details.</li>
      </ul>
      <p *ngIf="isDev">
        <button (click)="runHeaderHook()" [disabled]="headerHookEnabled">{{ headerHookEnabled ? 'XHR hook enabled' : 'Run demo XHR hook (dev)' }}</button>
        <button (click)="runHookTestCall()" style="margin-left:8px;">Run test call (Healthz)</button>
      </p>
      <pre>/* Example: log Authorization headers set on XHR (Angular HttpClient uses XHR) */
const orig = XMLHttpRequest.prototype.setRequestHeader;
XMLHttpRequest.prototype.setRequestHeader = function(k, v) &#123;
  if ((k || '').toLowerCase() === 'authorization') console.log('[stolen]', v);
  return orig.apply(this, arguments);
&#125;;</pre>
      <div class="warning">
        Tokens in browser storage (session/local) are accessible to JavaScript and therefore vulnerable to XSS. Use a strict CSP and safe coding practices, or consider a BFF pattern with HttpOnly cookies.
      </div>
      <div class="info-panel">
        <h4>What is BFF + HttpOnly?</h4>
        <p>
          <strong>BFF (Backend-for-Frontend)</strong> is a small server that handles OAuth/OIDC with the IdP and stores session state in an <strong>HttpOnly</strong> cookie. The browser never sees tokens; the BFF adds auth when calling downstream APIs. HttpOnly cookies are sent by the browser automatically, but are not readable by JavaScript, which mitigates token theft via XSS.
          <br />
          <strong>Note:</strong> This demo is a client-side SPA exercise and <em>does not implement BFF</em>. We include the concept for comparison only.
        </p>
      </div>
    </div>

    <h4>Select Storage Strategy</h4>
    <div class="spaced">
      <label><input type="radio" name="storageStrategy" (change)="storageSelect('memory')" [checked]="storageStrategy==='memory'" /> Memory</label>
      <label style="margin-left:12px;"><input type="radio" name="storageStrategy" (change)="storageSelect('session')" [checked]="storageStrategy==='session'" /> sessionStorage</label>
      <label style="margin-left:12px;"><input type="radio" name="storageStrategy" (change)="storageSelect('local')" [checked]="storageStrategy==='local'" /> localStorage</label>
    </div>

    <p>
      <button (click)="storageSaveToSelected()" [disabled]="!accessToken">Save current access token to selected</button>
      <button (click)="storageClearSelected()">Clear selected storage</button>
      <button (click)="storageRefreshView()">Refresh view</button>
    </p>

    <div class="grid">
      <div>
        <h4>Memory</h4>
        <pre>{{ storageMemToken || 'n/a' }}</pre>
      </div>
      <div>
        <h4>sessionStorage</h4>
        <pre>{{ storageSessionToken || 'n/a' }}</pre>
      </div>
      <div>
        <h4>localStorage</h4>
        <pre>{{ storageLocalToken || 'n/a' }}</pre>
      </div>
    </div>
  </div>

  <!-- Idle vs Expiry -->
  <div class="tab-content" *ngIf="selectedLabTab==='idle'">
    <h3>Idle vs Expiration</h3>
    <div class="warning" *ngIf="disableExpiryLogout && expiryToastVisible">
      {{ expiryToastMessage }}
      <button (click)="rotateRefreshTokenNow()" style="margin-left:8px;">Refresh now</button>
      <button (click)="dismissExpiryToast()" style="margin-left:4px;">Dismiss</button>
    </div>
    <div class="info-panel">
      <p>
        Access tokens expire based on <em>exp</em>, regardless of user activity. Idle timers are a <em>UX policy</em> — after
        <strong>no user activity</strong> for a threshold, log out or re-auth. This demo tracks both clocks so you can see
        how they interact.
      </p>
    </div>
    <div class="grid">
      <div>
        <h4>Controls</h4>
        <div class="spaced">
          <label>Idle timeout (seconds): </label>
          <input type="number" [(ngModel)]="idleTimeoutSec" min="10" style="width:120px;" />
        </div>
        <div>
          <label><input type="checkbox" [(ngModel)]="idleAutoLogout" /> Auto-logout on idle</label>
        </div>
        <div style="margin-top:6px;">
          <label><input type="checkbox" [(ngModel)]="disableExpiryLogout" (change)="applyExpiryLogoutSetting()" /> Don't auto-logout on token expiry (lab)</label>
        </div>
        <p class="spaced">
          <button (click)="idleToggle()">{{ idleEnabled ? 'Disable Idle Monitor' : 'Enable Idle Monitor' }}</button>
          <button (click)="recordActivitySimulate()" [disabled]="!idleEnabled" style="margin-left:8px;">Simulate activity</button>
        </p>
      </div>
      <div>
        <h4>Status</h4>
        <ul>
          <li>Idle monitor: <strong>{{ idleEnabled ? 'enabled' : 'disabled' }}</strong></li>
          <li>Last activity: <strong>{{ lastActivityAt ? (lastActivityAt | date:'medium') : 'n/a' }}</strong></li>
          <li>Idle remaining: <strong>{{ idleRemainingSec !== null ? idleRemainingSec + 's' : 'n/a' }}</strong>
            <span *ngIf="idleEnabled && idleRemainingSec !== null && idleRemainingSec <= idleWarnSeconds" style="color:darkorange">(near idle)</span>
          </li>
          <li>Access token remaining: <strong>{{ accessTokenExpiresIn !== null ? accessTokenExpiresIn + 's' : 'n/a' }}</strong></li>
        </ul>
      </div>
    </div>
    <div class="warning" *ngIf="idleEnabled && idleRemainingSec === 0">
      Idle threshold reached. <span *ngIf="idleAutoLogout">Logged out automatically.</span><span *ngIf="!idleAutoLogout">Auto-logout disabled.</span>
    </div>
  </div>

  <!-- Multi-tab sync placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='multitab'">
    <h3>Multi-Tab Sync</h3>
    <p>Coming soon: coordinate auth state with BroadcastChannel, avoid refresh races, and propagate logout.</p>
  </div>

  <!-- Silent re-auth placeholder -->
  <div class="tab-content" *ngIf="selectedLabTab==='silent'">
    <h3>Silent Re-auth (prompt=none)</h3>
    <div class="warning">Dev-only: Attempt background re-auth when the IdP session is still valid.</div>
    <div class="info-panel">
      <p>
        Silent re-auth uses an off-screen frame to call the authorization endpoint with <code>prompt=none</code>.
        If the user still has a valid SSO session at the IdP, the realm can issue a new authorization code without
        UI, which the SPA exchanges for fresh tokens. This avoids interrupting the user when access tokens expire.
      </p>
      <h4>Constraints</h4>
      <ul>
        <li>CORS and cookies must permit the IdP to recognize the session.</li>
        <li>IdP config must allow <em>prompt=none</em> and the redirect context.</li>
        <li>Failure should gracefully fall back to interactive login.</li>
      </ul>
    </div>
    <p>
      Coming soon: a minimal iframe flow and safe failure handling.
    </p>
  </div>
  </div>
</div>
